import asset.pipeline.*
import asset.pipeline.fs.*

apply plugin: 'java'
apply plugin: 'spring-boot'
apply plugin: 'idea'
apply plugin: 'project-report'
apply plugin: 'jacoco'
apply plugin: 'com.github.kt3k.coveralls'
apply plugin: 'pmd'
apply plugin: 'findbugs'
apply plugin: 'asset-pipeline'

if (System.getenv("SNAP_CI").equals("true") && System.getenv("SNAP_PIPELINE_COUNTER") != null) {
    version = "1.0.${System.getenv("SNAP_PIPELINE_COUNTER")}"
} else {
    ext.sha = 'git rev-parse --short HEAD'.execute().in.text.trim()
    version = '1.0.' + sha + '-SNAPSHOT'
}

sourceCompatibility = 1.8
targetCompatibility = 1.8

buildscript {
    repositories {
        mavenLocal()
        mavenCentral()
        maven { url "http://repo.spring.io/snapshot" }
        maven { url "http://repo.spring.io/milestone" }
        maven { url 'http://dl.bintray.com/bertramlabs/asset-pipeline' }
    }
    dependencies {
        classpath 'org.springframework.boot:spring-boot-gradle-plugin:1.2.2.BUILD-SNAPSHOT'
        classpath 'org.springframework:springloaded:1.2.2.BUILD-SNAPSHOT'
        classpath 'org.kt3k.gradle.plugin:coveralls-gradle-plugin:2.3.1'
        classpath 'com.bertramlabs.plugins:asset-pipeline-gradle:2.0.19'
        classpath 'com.bertramlabs.plugins:sass-asset-pipeline:2.0.4'
    }
}

repositories {
    mavenLocal()
    mavenCentral()
    maven { url "http://repo.spring.io/snapshot" }
    maven { url "http://repo.spring.io/milestone" }
    maven { url "https://oss.sonatype.org/content/repositories/public" }
}

sourceSets {
  integrationTest { sourceSet ->
    ["java", "resources"].each {
      if (!sourceSet.hasProperty(it)) return
      sourceSet."$it".srcDir file("$projectDir/src/test-integration/${it}")
    }
  }
}

dependencies {
    compile 'org.projectlombok:lombok:1.16.2'
    compile 'org.slf4j:slf4j-api:1.7.7'
    compile 'org.springframework.boot:spring-boot-starter-web'
    compile 'org.springframework.boot:spring-boot-starter-thymeleaf'
    compile 'org.springframework.boot:spring-boot-starter-actuator'
    compile 'org.springframework.boot:spring-boot-starter-data-elasticsearch'

    compile 'org.jolokia:jolokia-osgi:1.2.2'
    compile 'org.pegdown:pegdown:1.4.2'
    compile 'com.github.slugify:slugify:2.1.3'
    compile 'com.google.code.findbugs:annotations:3.0.0'

    testCompile 'junit:junit:4.11'
    testCompile 'org.mockito:mockito-core:1.9.5'
    testCompile 'org.springframework.boot:spring-boot-starter-test'

    integrationTestCompile sourceSets.main.output
    integrationTestCompile sourceSets.test.output
    integrationTestCompile configurations.testCompile
    integrationTestRuntime configurations.runtime
}

def ignoredSources = [
    "br/gov/servicos/legado/**/*Type*",
    "br/gov/servicos/legado/**/ObjectFactory.class"
]

test {
    testLogging {
        showStandardStreams = false
        exceptionFormat "full"
    }

    jacoco {
        excludes = ignoredSources
    }
}

tasks.withType(FindBugs) {
    reports {
        xml.enabled = false
        html.enabled = true
    }
}

jacocoTestReport {
    doFirst {
        classDirectories = fileTree(dir: "${buildDir}/classes/main/").exclude(ignoredSources)
        executionData = fileTree(dir: "$buildDir/jacoco", include: '**/*.exec')
    }

    reports {
        xml.enabled = true // coveralls plugin depends on xml format report
        html.enabled = true
    }
}

def mainAssets = "$projectDir/src/main/assets"
def staticAssets = "$buildDir/resources/main/static/assets"

assets {
    assetsPath = mainAssets
    compileDir = staticAssets
}

clean << {
    project.file('app.jar').delete()
}

def rpmBaseDir = file("$buildDir/rpmbuild")
def rpmDirs = files(
    "$rpmBaseDir/RPMS",
    "$rpmBaseDir/SRPMS",
    "$rpmBaseDir/BUILD",
    "$rpmBaseDir/SOURCES",
    "$rpmBaseDir/SPECS"
)

task prepareRpm(type:Copy) {
    delete(rpmBaseDir)
    rpmDirs.each {f -> f.mkdirs()}

    from "$buildDir/libs"
    include "${project.name}-${version}.jar"
    into "$rpmBaseDir/SOURCES"
}

task buildRpm(type: Exec) {
    dependsOn assemble, prepareRpm

    if (System.getenv("SNAP_CI").equals("true")) {
        commandLine 'bash', '-c',
            "rpmbuild -v -bb " +
            "--define '_topdir $rpmBaseDir' " +
            "--define 'version ${version.replace('-SNAPSHOT', '')}' " +
            "${project.name}.rpmspec"
    }
    else if (new File('/vagrant').exists()) {
        commandLine 'bash', '-c',
            "cd /vagrant && " +
            "rpmbuild -v -bb " +
            "--define '_topdir $rpmBaseDir' " +
            "--define 'version ${version.replace('-SNAPSHOT', '')}' " +
            "${project.name}.rpmspec"
    } else {
        commandLine 'vagrant', 'ssh', 'app', '-c',
            "cd /vagrant && " +
            "rpmbuild -v -bb " +
            "--define '_topdir /vagrant/build/rpmbuild' " +
            "--define 'version ${version.replace('-SNAPSHOT', '')}' " +
            "${project.name}.rpmspec"
    }
}

task vagrantDeploy(type: Exec) {
    dependsOn buildRpm

    String cmd = "cd /vagrant && bash ./scripts/vagrant-deploy " +
            "build/rpmbuild/RPMS/noarch/${project.name}-${version.replace('-SNAPSHOT', '')}-1.noarch.rpm"

    if (new File('/vagrant').exists()) {
        commandLine 'bash', '-c', cmd
    } else {
        commandLine 'vagrant', 'ssh', 'app', '-c', cmd
    }
}

task integrationTest(type: Test) {
    description = "Run all integration tests"
    testClassesDir = sourceSets.integrationTest.output.classesDir
    classpath = sourceSets.integrationTest.runtimeClasspath

    jacoco {
        destinationFile = file("$buildDir/jacoco/integrationTest.exec")
        classDumpFile = file("$buildDir/classes/integrationTest")
    }
}
check.dependsOn(integrationTest)

task stage(type: Copy, dependsOn: [clean, assemble]) {
    from jar.archivePath
    into project.rootDir
    rename {
        'app.jar'
    }
}
stage.mustRunAfter(clean)

task watchAssets << {
    def assetsSrcFolder = new File(mainAssets)
    def lastCompilationByPath = [:]

    def shouldCompileAssets = {
        def shouldCompile = false

        assetsSrcFolder.traverse {
            def lastCompilation = lastCompilationByPath[it.absolutePath] ?: 0
            shouldCompile = shouldCompile || lastCompilation < it.lastModified()
            lastCompilationByPath[it.absolutePath] = it.lastModified()
        }

        shouldCompile
    }

    shouldCompileAssets() // Just fetch the last modified timestamp

    AssetPipelineConfigHolder.registerResolver(new FileSystemAssetResolver('application', mainAssets))
    def compiler = new AssetCompiler([compileDir: staticAssets])

    Thread.startDaemon {
        while(true) {
            try {
                if (shouldCompileAssets()) compiler.compile()
                Thread.sleep(500)
            } catch(any) {
                println any
            }
        }
    }
}
bootRun.dependsOn(watchAssets)
processResources.dependsOn(assetCompile)

idea {
    module {
        inheritOutputDirs = false
        outputDir = file("$buildDir/classes/main/")
        testOutputDir = file("$buildDir/classes/test/")
        excludeDirs += files(
                '.git-crypt',
                '.vagrant',
                '.sass-cache',
                '.sass-work',
                '.jruby-container',
                'data',
                'gradle',
                'docs/_book',
                'tmp'
        )

        testSourceDirs += project.sourceSets.integrationTest.java.srcDirs
        testSourceDirs += project.sourceSets.integrationTest.resources.srcDirs

        //o ideal seria ter um testResourceDirs também, para não ter que fazer o que acontece abaixo
        iml.withXml { xmlFile ->
            // mark test/resource as a resource folder
            def atts = xmlFile.asNode().component.content.sourceFolder.find { it.@url == 'file://$MODULE_DIR$/src/main/resources' } .attributes()
            atts.remove('isTestSource')
            atts.put('type', 'java-resource')

            atts = xmlFile.asNode().component.content.sourceFolder.find { it.@url == 'file://$MODULE_DIR$/src/test/resources' } .attributes()
            atts.remove('isTestSource')
            atts.put('type', 'java-test-resource')

            atts = xmlFile.asNode().component.content.sourceFolder.find { it.@url == 'file://$MODULE_DIR$/src/test-integration/resources' } .attributes()
            atts.remove('isTestSource')
            atts.put('type', 'java-test-resource')
        }
    }

    project {
        ipr.withXml { xmlFile ->
            // enable 'Annotation Processors'
            xmlFile.asNode().component.find { it.@name == 'CompilerConfiguration' }['annotationProcessing'][0].replaceNode {
                annotationProcessing { profile(default: true, name: 'Default', useClasspath: 'true', enabled: true) }
            }

            // setup Git root
            xmlFile.asNode().component.find { it.@name == 'VcsDirectoryMappings' }.replaceNode {
                component(name: 'VcsDirectoryMappings') {
                    mapping(directory: "", vcs: "")
                    mapping(directory: "\$PROJECT_DIR\$", vcs: 'Git')
                }
            }
        }
    }
}

